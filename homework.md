# Руководство по работе с Git.

## Что такое Git и зачем он нужен?

*Git* - это консольная утилита, для отслеживания и ведения истории изменения файлов, в вашем проекте.

С помощью *Git*-a вы можете откатить свой проект до более старой версии, сравнивать, анализировать или сливать свои изменения в репозиторий.

Репозиторием называют хранилище вашего кода и историю его изменений. *Git* работает локально и все ваши репозитории хранятся в определенных папках на жестком диске.

Так же ваши репозитории можно хранить и в интернете. Обычно для этого используют три сервиса:

* [GitHub](https://github.com/)

* [Bitbucket](https://bitbucket.org/)

* [GitLab](https://gitlab.com/)

Каждая точка сохранения вашего проекта носит название коммит (commit). У каждого commit-a есть hash (уникальный id) и комментарий. Из таких commit-ов собирается ветка. Ветка - это история изменений. У каждой ветки есть свое название. Репозиторий может содержать в себе несколько веток, которые создаются из других веток или вливаются в них.

## Установка

* Windows. Проходим по [этой ссылке](https://git-scm.com/download/win), выбираем под вашу ОС (32 или 64 битную), скачиваем и устанавливаем.

* Для Mac OS. Открываем терминал и пишем:

~~~
Если установлен Homebrew
brew install git

#Если нет, то вводим эту команду. 
git --version

#После этого появится окно, где предложит установить Command Line Tools (CLT).
#Соглашаемся и ждем установки. Вместе с CLT установиться и git
~~~

* Linux. Открываем терминал и вводим следующую команду.

~~~
# Debian или Ubuntu
sudo apt install git

# CentOS
sudo yum install git
~~~

## Настройка

Вы установили себе Git и можете им пользоваться. Давайте теперь его настроим, чтобы когда вы создавали commit, указывался автор, кто его создал.

Открываем терминал (Linux и MacOS) или консоль (Windows) и вводим следующие команды.

~~~
#Установим имя для вашего пользователя
#Вместо <ваше_имя> можно ввести, например, Grisha_Popov
#Кавычки оставляем
git config --global user.name "<ваше_имя>"

#Теперь установим email. Принцип тот же.
git config --global user.email "<адрес_почты@email.com>"
~~~

## Создание репозитория

Создадим наш первый репозиторий. Для этого пройдите в папку вашего проекта.

~~~
#Для Linux и MacOS путь может выглядеть так /Users/UserName/Desktop/MyProject
#Для Windows например С://MyProject
cd <путь_к_вашему_проекту>

#Инициализация/создание репозитория
git init
~~~

Теперь Git отслеживает изменения файлов вашего проекта. Но, так как вы только создали репозиторий в нем нет вашего кода. Для этого необходимо создать commit.

~~~
#Добавим все файлы проекта в нам будующий commit
git add .
#Или так
git add --all

#Если хотим добавить конкретный файл то можно так
git add <имя_файла> 

#Теперь создаем commit. Обязательно указываем комментарий.
#И не забываем про кавычки
git commit -m "<комментарий>"
~~~

## Основные команды

**git add**

>Команда `git add` добавляет содержимое рабочего каталога в индекс (staging area) для последующего коммита. По умолчанию `git commit` использует лишь этот индекс, так что вы можете использовать `git add` для сборки слепка вашего следующего коммита.

**git commit**

>Команда `git commit` берёт все данные, добавленные в индекс с помощью `git add`, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

**git status**

>Команда `git status` показывает состояния файлов в рабочем каталоге и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

**git diff**

>Команда `git diff` используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей копией и индексом (собственно `git diff`), разница между индексом и последним коммитом (`git diff --staged`), или между любыми двумя коммитами (`git diff master branchB`).

**git difftool**

>Команда `git difftool` просто запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите использовать что-либо отличное от встроенного просмотрщика `git diff`.

**git reset**

>Команда `git reset`, как можно догадаться из названия, используется в основном для отмены изменений. Она изменяет указатель `HEAD` и, опционально, состояние индекса. Также эта команда может изменить файлы в рабочем каталоге при использовании параметра `--hard`, что может привести к потере наработок при неправильном использовании, так что убедитесь в серьёзности своих намерений прежде чем использовать его.

**git rm**

>Команда `git rm` используется в Git для удаления файлов из индекса и рабочей копии. Она похожа на `git add` с тем лишь исключением, что она удаляет, а не добавляет файлы для следующего коммита.

**git mv**

>Команда `git mv` — это всего лишь удобный способ переместить файл, а затем выполнить `git add` для нового файла и `git rm` для старого.

**git clean**

>Команда `git clean` используется для удаления мусора из рабочего каталога. Это могут быть результаты сборки проекта или файлы конфликтов слияний.

**git log**

>Просматривать изменения, внесённые в репозиторий, можно с помощью параметра `log`. Он отображает список последних коммитов в порядке выполнения. Кроме того, добавив флаг `-p`, вы можете подробно изучить изменения, внесённые в каждый файл.

**git checkout**

>Восстановить файлы рабочего дерева, не подготовленные к коммиту, можно параметром `checkout`. Для проведения операции требуется указать путь к файлу. Если путь не указан, параметр `git checkout` изменит указатель `HEAD`, чтобы задать указанную ветку как текущую.

## Ветвление 

Под веткой принято понимать независимую последовательность коммитов в хронологическом порядке. Однако конкретно в Git реализация ветки выполнена как указатель на последний коммит в рассматриваемой ветке. После создания ветки уже новый указатель ссылается на текущий коммит.

Имя основной ветки Git-проекта по умолчанию — master (однако зачастую бывает main, например, в GitHub), она появляется сразу при инициализации репозитория. Эта ветка ничем не отличается от остальных и также ее можно переименовать, но по договоренности master принято считать главной веткой в проекте.

### Способы создания веток и переключения между ними

Команда `git branch` — главный инструмент для работы с ветвлением. С ее помощью можно добавлять новые ветки, перечислять и переименовывать существующие и удалять их.

Чтобы в Git добавить ветку мы используем:
~~~
git branch <name of new branch>
~~~

После данной операции ветка уже была создана, но вы по-прежнему находитесь в прежней ветке. Если вы планируете переместиться на другую ветку, в том числе только что созданную, необходимо написать checkout:
~~~
git checkout <name of branch>
~~~
Для того чтобы определить, где сейчас находится разработчик, Git использует специальный указатель **HEAD**, ссылающийся на текущую локальную ветку. В результате checkout **HEAD** переместится на иную ветку.

Чаще всего при создании новой ветки git пользователю необходимо сразу же переключиться на нее. В таком случае стоит использовать:
~~~
git checkout branch <name of new branch>
~~~
И также мы получим тот же результат при использовании git checkout с ключом -b:
~~~
git checkout -b <name of branch>
~~~
Если пользователю нужно получить список определенного множества веток, то тогда можно воспользоваться ключами. Одними из самых распространенных будут:

* `-r` - при использовании этого ключа мы получим список удаленных веток

* `-a` - используя этот параметр, в выводе будут удаленные и локальные ветки.

### Основы ветвления и слияния

Ветвление позволяет разделять рабочий процесс, оптимизировать тестирование и написание нового кода. Однако после того, как разработчик убедился, что написанный им кусок кода готов и его можно отправить к остальной части итоговой версии, удобно переместить его в основную ветку. Такой подход дает возможность получить к концу разработки проекта целый продукт в одном месте.
Для этого в Git предусмотрено слияние — перенос изменений с одной ветки на другую. Однако сливаемая ветка (под этим определением мы подразумеваем ветку, у которой берем изменения для «вливания» их в другую ветвь) никак не меняется и остается в прежнем состоянии. Такие преобразования мы получаем, применив `git merge`:
~~~
git merge <name of merged branch>
~~~
Операция может привести к появлению конфликтов при попытке слить ветки. Это вызвано тем, что изменения удаляют или переписывают информацию в существующих файлах. При попытке некорректного слияния Git останавливает выполнение команды, чтобы вы могли разрешить конфликт.

Также стоит упомянуть о существовании ключей, предназначенных специально для работы с конфликтами:

* `-abort` - прерывает слияние и возвращает все к началу

* `-continue` - продолжает слияние после разрешения конфликта

Решить конфликт можно двумя способами:

* Вручную разрешить файловый конфликт. Для этого нужно самим изменить файлы, с которыми возникли проблемы. Мы получим файлы такими, какими и представляли их при попытке слияния.

* Выбрать более подходящий файл, а от второго отказаться.

### Управление ветками с помощью git branch

Эта команда может немного больше, чем просто в git создавать ветки из текущей. Если запустить ее без параметров:
~~~
git branch
~~~

При выполнении этой строки мы получим список существующих веток, где символом * будет отмечена ветка, где вы сейчас находитесь. Это может выглядеть так:
~~~
first_branch
* master
second_branch
~~~

С помощью параметра -v можно получить последний сохраненный коммит в каждой ветке.
~~~
git branch -v
  first_branch 8fa301b Fix math
* master 225cc2d Merge branch 'first_branch'
  second_branch c56ee12 Refactor code style
~~~

Так же существуют опции `-merged` и `-no-merged`, с помощью которых можно отфильтровать полученную последовательность веток. То есть мы получим список ответвлений, которые уже были слиты, или, наоборот, ветки, которые еще не прошли через слияние с другими. Выведем ветки, которые уже были слиты с текущей:
~~~
git branch --merged
  first_branch
* master
~~~

## Удаленный репозиторий (на примере Github)

Перейдите на https://github.com и войдите в свой аккаунт. Нажмите кнопку **New repository** (Новый репозиторий). На открывшейся странице введите имя репозитория (Repository name) и нажмите кнопку **Create repository**.

В своем локальном репозитории теперь выполните команду:
~~~
git remote add origin https://github.com/username/myproject.git
~~~

Данная команда добавит удаленный репозиторий с именем `origin`, который указывает на ваш Github-репозиторий. Пока мы только добавили запись об удаленном репозитории.

Теперь можно выполнить команду `git push`, чтобы отправить все ваши изменения на удаленный репозиторий:
~~~
git push -u origin master
~~~
Вам нужно будет ввести логин и пароль аккаунта в Github. Результат команды будет примерно следующим:
~~~
git push -u origin master
Username for 'https://github.com': youremail@email.com
Password for 'https://youremail@email.com@github.com':
Counting objects: 4, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (4/4), 252 bytes | 252.00 KiB/s, done.
Total 4 (delta 0), reused 0 (delta 0)
remote:
remote: Create a pull request for 'master' on GitHub by visiting:
remote: https://github.com/username/myproject/pull/new/master
remote:
To https://github.com/username/myproject.git
* [new branch] master -> master
Branch 'master' set up to track remote branch 'master' from 'origin'.
~~~
В команде `git push` мы использовали ключ `-u`. Данный ключ используется для того, чтобы связать локальную ветку `master` с удаленной `origin/master` (в нашем случае удаленной ветки не существовало, она автоматически была создана). Так как связь установлена, то последующие выполнения `git push` из ветки мастер можно выполнять без указания веток. То есть вместо `git push origin master`, можно просто выполнять команду `git push`.

### Клонировать удаленный репозиторий

Если у других пользователей возникла необходимость клонировать удаленный репозитарий, они могут получить полностью работоспособную копию при помощи команды `clone`:
~~~
git clone https://github.com/username/myproject
~~~
GitHub автоматически создаст новый локальный репозиторий в виде удаленного на собственном сервере.

В случае, если другим пользователям нет необходимости делать клон удаленного репозитория, а нужно просто получить информацию об изменениях, это можно сделать с помощью команды `pull`:
~~~
git pull origin master
From https://github.com/username/myproject
* branch master -> FETCH_HEAD
Already up-to-date.
~~~
Она скачивает новые изменения. Так как мы ничего нового не вносили с тех пор, как клонировали проект, изменений, доступных к скачиванию, нет.

